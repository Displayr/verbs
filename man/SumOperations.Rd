% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sum.R, R/sumcolumns.R, R/sumrows.R
\name{Sum}
\alias{Sum}
\alias{SumColumns}
\alias{SumRows}
\title{General-Purpose Summation functions}
\usage{
Sum(
  ...,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = c("NET", "SUM", "Total"),
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

SumColumns(
  ...,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = c("NET", "SUM", "Total"),
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

SumRows(
  ...,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = c("NET", "SUM", "Total"),
  subset = NULL,
  weights = NULL,
  match.elements = "Yes - ignore if unmatched",
  warn = FALSE
)
}
\arguments{
\item{...}{Objects to be summed; e.g. Q Tables, arrays, vectors, Variables or Variable Sets.
Depending on if \code{Sum}, \code{SumRows} or \code{SumColumns} is used, different possible
multiple input types are allowed. See the}

\item{remove.missing}{Logical element controlling whether missing values should be
removed in calculations? Defaults to \code{TRUE}. If set to \code{FALSE} and if one of
input elements contains missing values, then the resulting computed sum will also be
\code{NA}.}

\item{remove.rows}{The labels of named vectors, or, rows of tables and similar
structures to be removed from the row dimension of the input. Any row elements
with the labels specified here will not be included in the resulting sum calculation.}

\item{remove.columns}{The labels of columns of tables and similar
structures to be removed from the column dimension of the input. Any column elements
with the labels specified here will not be included in the resulting sum calculation.}

\item{subset}{Logical vector of units to use in the calculation. Only applied to variables and
not to \code{Q Table}s that contain statistics since the original variable data is unavailable.}

\item{weights}{Numeric vector of weights to use in the calculation. Only applies to variables
and not to \code{Q Table}s that contain statistics since the original variable data is unavailable.}

\item{warn}{Logical element to control whether warnings are shown when non-obvious
operations are performed (e.g., removing rows, removing missing values when they are present).
Possible warnings presented include \itemize{
  \item Whether missing values were identified and removed if \code{remove.missing}
    is set to \code{TRUE}
  \item Rows removed due to the options provided in \code{remove.rows}
  \item Columns removed due to the options provided in \code{remove.columns}
  \item Whether different statistics are being summed in the case of \code{Q Table}.
}}

\item{match.elements}{Character string specifying if elements should be matched
before calculation. This is only possible in the case of multiple single vectors
being given as inputs. In that case, their indices could be matched using their
names via an exact match or fuzzy match before calculation occurs. The details of
the available options are:
 \itemize{
  \item \code{"Yes - ignore if unmatched"} Perform an exact name match between
  input elements. Any elements that are not matched in the other outputs are permissible
  and an element with value zero is appended in that case before calculation occurs.
  See examples for more information.
  \item \code{"Yes - error if unmatched"} Performs an exact name match between
  input elements. However, any named elements that are not completely matched will
  trigger an error to be thrown.
  \item \code{"Fuzzy - ignore if unmatched"} Performs fuzzy name matching. First
  an exact name match is performed, any remaining unmatched elements are attempted to
  be matched using near matches using the Levenshtein distance. The algorithm will
  match elements that have a one-to-one matching with a Levenshtein distance of
  at most 1 unit, ignoring case. Following this, some common variants of questionnaire
  reponses are attempted to be matched. E.g. \code{"None of these"} could be matched
  with \code{"none"}. This occurs for variants of \code{"Other"}, \code{"All of these"}
  and variants of \code{"Don't know"}. If further unmatched elements exist, punctuation
   and white space are removed and matches attempted. If any unmatched still exist, then
  they are appended a value of zero before calculation in the same manner as
  \code{"Yes - ignore if unmatched"}.
  \item \code{"Fuzzy - error if unmatched"} Performs fuzzy name matching as above.
    However, if any unmatched elements remain after the fuzzy matching has been
    performed will trigger an error.
  \item \code{"No"} No matching is to occur with the input elements to be stacked
   together before calculation. Assuming the elements are of the same row length.
}}
}
\value{
The \code{Sum} function returns the summation of all the elements provided in the input,
  possibly after the elements have had entries removed, filtered out or weighted using the .The sum or sum of the rows or sum of the columns of the provided inputs respectively
  depending on the function used.

The \code{SumColumns} function returns the summation of all the elements in each column
  index provided in the input, possibly after the elements have been pre-processed similar
  to \code{Sum}.

The \code{SumRows} function returns the summation of all the elements in each row
  index provided in the input, possibly after the elements have been pre-processed similar
  to \code{Sum}. However, \code{SumRows} also allows elements to be matched by name.
}
\description{
A generalisation of \code{\link{sum}}, \code{\link{colSums}} and \code{\link{rowSums}}
 supporting additional pre-processing and matching of data before calculation.
}
\details{
The \code{Sum} function takes all the input elements and processes the inputs according
 to the other specified input options above. Then sums together the remaining elements to produce a
 single scalar value.

If a single input is provided to \code{SumRows} and \code{SumColumns}, it is
 permissible to be a \code{numeric} vector, \code{data.frame}, \code{Q Table}, \code{matrix} or
 other possible structure that has well defined rows or columns. An array is only
 permissible if it has 2 dimensions. Higher order arrays are only allowed in the form of
 a \code{Q Table}. Multiple inputs are allowed but only if each input is a single \code{numeric}
 vector. i.e. multiple \code{data.frame}s or matrices etc. are not allowed.

 For \code{SumRows} the summation only occurs separately for each row of the
 provided input. E.g. a n x p matrix supplied to \code{SumRows} will produce a vector
 of length \code{n} and possible be named with the same names as the row names of the
 input matrix. A named vector of length \code{n} is interpreted as a structure with
 \code{n} rows and 1 column. Meaning that a single vector input to \code{SumRows} will
 typically return the same input vector (assuming no rows are removed or the vector is
 filtered by the \code{subset} argument).

 \code{SumRows} has an extra feature in that it supports matching rows by name. If multiple
 named vectors are given as input, their indices could be matched using their names via an
 exact match or fuzzy match (see the \code{match.elements} argument). These elements are
 matched before calculation occurs.
}
\examples{
# Examples using Sum
Sum(1:3, 2:4)
all.equal(Sum(1:3, 2:4), sum(1:3, 2:4))
x <- 1:4
names(x) <- c(LETTERS[1:3], "SUM")
Sum(x)
x <- 1:9
desired.subset = rep(c(TRUE, FALSE), c(3, 6))
Sum(x, subset = desired.subset)
desired.weights <- runif(9)
y <- 10:18
Sum(x, y, weights = desired.weights)
sum(x * desired.weights, y * desired.weights)
basic.table <- matrix(1:12, nrow = 4, dimnames = list(letters[1:4], LETTERS[1:3]))
table.with.marginals <- rbind(basic.table, SumColumns(basic.table))
table.with.marginals <- cbind(table.with.marginals, c(SumRows(basic.table), Sum(basic.table)))
dimnames(table.with.marginals) <- list(c(letters[1:4], "SUM"), c(LETTERS[1:3], "SUM"))
all.equal(Sum(table.with.marginals), sum(basic.table))
# Examples using SumColumns
input.matrix <- matrix(1:8, nrow = 4)
SumColumns(input.matrix) #= c(10, 26)
named.matrix <- input.matrix
dimnames(named.matrix) <- list(LETTERS[1:4], letters[1:2])
SumColumns(named.matrix)
SumColumns(named.matrix, remove.rows = c("A", "C"))
SumColumns(named.matrix, remove.columns = "a")
SumColumns(named.matrix, subset = c(TRUE, FALSE, TRUE, FALSE))
SumColumns(named.matrix, remove.rows = c("B", "D"))
# Each element is summed individually
# The order of input determines the order of output.
w <- c(a = 1, b = 2, c = 3, d = 4)
x <- c(a = 1, b = 2)
y <- c(b = 3, c = 10)
z <- c(c = -1, d = 3)
SumColumns(w, x, y, z)
SumColumns(z, y, x, w)
SumColumns(sample(w), sample(x), sample(y), sample(z))
# Examples using SumRows
SumRows(input.matrix) #= c(6, 8, 10, 12)
SumRows(named.matrix)
SumRows(named.matrix, remove.rows = c("A", "C"))
SumRows(named.matrix, remove.columns = "a")
SumRows(named.matrix, subset = c(TRUE, FALSE, TRUE, FALSE))
SumRows(named.matrix, remove.rows = c("B", "D"))
# Due to the default row matching all the below
# will evaluate to the equivalent of c(a = 2, b = 7, c = 12, d = 7)
# It will differ on the order of the elements, not the evaluated content
SumRows(w, x, y, z)
SumRows(z, y, x, w)
SumRows(sample(w), sample(x), sample(y), sample(z))
# This will error since there are elements with no match
# SumRows(x, y, match.elements = 'Yes - error if unmatched')
X <- x
names(X) <- toupper(names(x))
Z <- z
names(Z) <- toupper(names(z))
# In the exact match case, it is case sensitive
SumRows(w, X, y, Z, match.elements = "Yes - ignore if unmatched")
SumRows(w, X, y, Z, match.elements = "Fuzzy - ignore if unmatched")
SumRows(w, x, y, z)
}
