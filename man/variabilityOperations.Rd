% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/variance-columns.R, R/variance-rows.R,
%   R/variance.R
\name{VarianceEachColumn}
\alias{VarianceEachColumn}
\alias{StandardDeviationEachColumn}
\alias{VarianceColumns}
\alias{StandardDeviationColumns}
\alias{VarianceEachRow}
\alias{StandardDeviationEachRow}
\alias{VarianceRows}
\alias{StandardDeviationRows}
\alias{Variance}
\alias{StandardDeviation}
\title{General-Purpose Calculation of Variance and Standard Deviation}
\usage{
VarianceEachColumn(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = NULL,
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

StandardDeviationEachColumn(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = NULL,
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

VarianceColumns(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = NULL,
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

StandardDeviationColumns(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  remove.columns = NULL,
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

VarianceEachRow(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  warn = FALSE
)

StandardDeviationEachRow(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  warn = FALSE
)

VarianceRows(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  warn = FALSE
)

StandardDeviationRows(
  x,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  warn = FALSE
)

Variance(
  ...,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = NULL,
  match.elements = "Yes",
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

StandardDeviation(
  ...,
  sample = TRUE,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = NULL,
  match.elements = "Yes",
  subset = NULL,
  weights = NULL,
  warn = FALSE
)
}
\arguments{
\item{x}{A single input to be used in \code{VarianceEachRow} or \code{VarianceEachColumn}.}

\item{sample}{Logical to determine which formula to use. If \code{TRUE}, then
the sample variance (standard deviation) is used. Otherwise, the population
variance (standard deviation) formula is used.}

\item{remove.missing}{Logical element controlling whether missing values should be
removed in calculations? Defaults to \code{TRUE}. If set to \code{FALSE} and if one of
input elements contains missing values, then the resulting computed sum will also be
\code{NA}.}

\item{remove.rows}{The labels of named vectors, or, rows of tables and similar
structures to be removed from the row dimension of the input. Any row elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{remove.columns}{The labels of columns of tables and similar
structures to be removed from the column dimension of the input. Any column elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{subset}{Logical vector of units to use in the calculation. Only applied to variables and
not to Q Tables that contain statistics since the original variable data is unavailable.}

\item{weights}{Numeric vector of weights to use in the calculation. It is required to have the same
number of elements as there are rows in the inputs as the weight vector is applied across the row
dimension (elements in different columns but the same row will have the same weight element applied). The
exception to this is that weights will not be applied to Q Tables containing statistics since
the original variable data is unavailable.}

\item{warn}{Element to control whether warnings are shown when non-obvious
operations are performed. If a logical (\code{TRUE} or \code{FALSE} then all warnings are
thrown or suppressed respectively. If a string is used then warnings are thrown except for
the missing values ignored warning which is suppressed. Other possible warnings presented
include \itemize{
  \item Whether missing values were identified and removed if \code{remove.missing}
    is set to \code{TRUE}
  \item Whether different statistics are being summed in the case of Q Table.
  \item Whether unmatched rows or columns have been removed from the calculation if the user
  has specified for unmatched elements to be hidden.
  \item Whether any inputs have been recycled to higher dimensional forms.
}}

\item{...}{Input objects to compute the variance or standard deviation;
e.g. vectors, matrices, Variables, Variable Sets or Q Tables}

\item{match.elements}{Either a single string with three possible options or named character vector with two
elements. The possible single character options are: \itemize{
\item "No": Ignores names and requires either inputs which the same dimensions
      or partially agreeing where recycling can be performed. See details for more information.
\item "Yes - hide unmatched" or "Yes": Performs a matching algorithm that checks row names and column names
      of all elements and attempts to match the appropriate elements. The matching
      will check both exact matches or fuzzy matches and permutes the order of the elements
      so that the names match. It also may transpose an input if,
      for example, the column names of one input match the row names of another input.
      Any unmatched elements are removed from the input before calculation.
\item "Yes - show unmatched": Performs the same matching algorithm above but any
      unmatched elements are kept in the input. The other input without the element has
      missing values spliced in.
      }
 A named character vector is possible but it must have two elements named \code{rows}
 or \code{columns} (partial matching names permissible) that specify the matching behavior
 for rows and columns.
 E.g. \code{match.elements = c(rows = "Yes - hide unmatched", columns = "No")} to specify
 that rows are to be matched but unmatched rows are to be removed from the calculation.
 The columns are not to be matched. The full set of alternatives for either \code{match.rows}
 or \code{match.columns} are given below but are described only for the row scenario.
\itemize{
  \item \code{"Yes"} or \code{"Yes - hide unmatched"}: Perform an exact name match between
  the row names of input elements. Any unmatched row names will cause the entire row to be
  removed before calculation.
  \item \code{"Yes - show unmatched"} Performs an exact name match between
  input elements in the same manner as \code{"Yes"} option. However, any row names that are
  not matched in the other outputs are permissible. The input that doesn't have that row
  will have a row of missing values spliced in. The resulting row will either be \code{NA} if
  \code{remove.missing} is set to \code{FALSE} or zero if \code{remove.missing} is set
  to \code{TRUE}.
  \item \code{"Fuzzy"} Same behaviour as \code{"Yes"} except the matching uses fuzzy name
  matching. First an exact name match is performed, any remaining unmatched elements are attempted to
  be matched using near matches using the Levenshtein distance. The algorithm will
  match elements that have a one-to-one matching with a Levenshtein distance of
  at most 1 unit, ignoring case. Following this, some common variants of questionnaire
  reponses are attempted to be matched. E.g. \code{"None of these"} could be matched
  with \code{"none"}. This occurs for variants of \code{"Other"}, \code{"All of these"}
  and variants of \code{"Don't know"}. If further unmatched elements exist, punctuation
   and white space are removed and matches attempted.
  \item \code{"Fuzzy - show unmatched"} Similar to \code{"Fuzzy"} except any unmatched row
  names will have a row of missing values spliced in similar to \code{"Yes - show unmatched"}.
  \item \code{"No"} No matching is to occur with the row names. In this case, all
  input elements need to have the same number of rows.
  }}
}
\value{
The \code{VarianceEachColumn} function returns the variance of all the elements in each column
  index provided in the input, possibly after the elements have been filtered, weights applied or rows
  removed via the provided calling arguments.

The \code{VarianceEachRow} function returns the variance of all the elements in each row
  index provided in the input, possibly after some rows have been removed via the \code{remove.rows}
  argument.

If a single input is provided, a single number is returned,
    the (possibly weighted) variance or standard deviation of all
    the elements. If multiple inputs, the output will have the same
    dimension as the input or possibly reduced dimension if matching
    based on dimension names is performed. It contains the variance or
    standard deviation computed element-wise.
}
\description{
In a similar way, \code{VarianceEachColumn} is an extension of \code{\link{Variance}} for
 single inputs and also supporting the application of filters and weights before calculation
 but not supporting multiple inputs.
 The functions \code{VarianceColumns} and \code{VarianceRows} are aliases for
 \code{VarianceEachColumn} and \code{VarianceEachRow}.

Also, \code{VarianceEachRow} is an extension of \code{\link{Variance}} for single
 inputs where the variance of each row is computed instead of all elements. Similar to the
 other functions in verbs, the input can be processed to remove rows or column before calculation
 is done.

\code{Variance} (\code{StandardDeviation}) is computes variance
    (standard deviation) \code{\link{var}} but supporting additional
    pre-processing, matching and weighting of data before calculation.
}
\details{
The \code{VarianceEachRow} and \code{VarianceEachColumn} only support a single input \code{x}.
 The permissible input is a \code{numeric} vector, \code{array} with at most 2 dimensions, a \code{data.frame},
 Q Table, \code{matrix} or other possible structure that has well defined rows or columns.

 In the case of a vector of length n, it is interpreted to be an input with n rows and
 a single column. An array is only permissible if it has 2 dimensions, the exception being
 higher order arrays are only allowed in the form of a Q Table.

 For \code{VarianceEachColumn}, the column names of the inputs if provided are used to define the names
 in the output vector.

For \code{VarianceEachRow} the variance is computed within the row dimension of the input.
 E.g. a n x p matrix supplied to \code{VarianceEachRow} will produce a vector of of length \code{n}.
 If names are provided in the row dimension of the input then the output will have the same
 row names.

If a single input is provided, then the variance or standard deviation
    of all elements in the input is calculated (after possible subsetting or
    weighting). If multiple inputs are provided, then element-wise calculation
    of the variance is performed.

    If the inputs have named elements, then these names can be used to
    match up each of the elements between inputs via the
    \code{match.rows} and \code{match.columns} arguments. If either
    of \code{match.rows} or \code{match.columns} is set to
    \code{"No"} then names are ignored and the length on that
    dimension needs to agree between inputs. Partial dimension
    agreement is also supported. For example if an n x p matrix is
    used as the first input, then the second input could be an n x
    1 column vector that is recycled to an n x p matrix before
    calculation.
}
\examples{
# Examples using VarianceEachColumn
input.matrix <- matrix(1:8, nrow = 4)
wgts <- runif(4)
VarianceEachColumn(input.matrix)
named.matrix <- input.matrix
dimnames(named.matrix) <- list(LETTERS[1:4], letters[1:2])
VarianceEachColumn(named.matrix)
VarianceEachColumn(named.matrix, weights = wgts)
VarianceEachColumn(named.matrix, remove.rows = c("A", "C"))
VarianceEachColumn(named.matrix, subset = c(TRUE, FALSE, TRUE, FALSE))
VarianceEachColumn(named.matrix, subset = c(TRUE, FALSE, TRUE, FALSE), weights = wgts)
VarianceEachColumn(named.matrix, remove.rows = c("B", "D"))
# Examples using VarianceEachRow
input.matrix <- matrix(runif(12), nrow = 6, dimnames = list(letters[1:6], c("Q1", "Q2")))
var.row <- VarianceEachRow(input.matrix)
sd.row <- StandardDeviationEachRow(input.matrix)
all.equal(sqrt(var.row), sd.row)
input.matrix.with.total <- cbind(input.matrix, "Total" = rowSums(input.matrix))
VarianceEachRow(input.matrix.with.total, remove.columns = "Total")
# Examples
X <- rnorm(12)
all.equal(Variance(X), var(X))
X.with.na <- sample(c(NA, runif(12)), size = 100, replace = TRUE)
var(X.with.na)
var(X.with.na, na.rm = TRUE)
Variance(X.with.na)
Variance(X.with.na, remove.missing = FALSE)
X <- replicate(3,
               array(sample(c(NA, runif(12)), size = 12, replace = TRUE), dim = 3:4,
                     dimnames = list(sample(letters[1:3]), sample(LETTERS[1:4]))),
               simplify = FALSE)
do.call(Variance, X)
X <- replicate(3,
               array(sample(c(NA, runif(12)), size = 12, replace = TRUE), dim = 3:4,
                     dimnames = list(sample(letters[1:3]), sample(LETTERS[1:4]))),
               simplify = FALSE)
all.equal(do.call(StandardDeviation, X), sqrt(do.call(Variance, X)))
}
