% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/average.R, R/averagecolumns.R, R/averagerows.R
\name{Average}
\alias{Average}
\alias{AverageColumns}
\alias{AverageRows}
\title{General-Purpose Averaging functions}
\usage{
Average(
  ...,
  remove.missing = TRUE,
  remove.rows = NULL,
  remove.columns = NULL,
  match.rows = "Yes",
  match.columns = "Yes",
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

AverageColumns(
  ...,
  remove.missing = TRUE,
  remove.rows = c("NET", "SUM", "Total"),
  subset = NULL,
  weights = NULL,
  warn = FALSE
)

AverageRows(
  ...,
  remove.missing = TRUE,
  remove.columns = c("NET", "SUM", "Total"),
  warn = FALSE
)
}
\arguments{
\item{...}{Objects to be averaged; e.g. vectors, matrices, Variables, VariableSets or Q Tables.}

\item{remove.missing}{Logical element controlling whether missing values should be
removed in calculations? Defaults to \code{TRUE}. If set to \code{FALSE} and if one of
input elements contains missing values, then the resulting computed sum will also be
\code{NA}.}

\item{remove.rows}{The labels of named vectors, or, rows of tables and similar
structures to be removed from the row dimension of the input. Any row elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{remove.columns}{The labels of columns of tables and similar
structures to be removed from the column dimension of the input. Any column elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{match.rows}{The names of the row elements of the inputs are inspected and compared.
If matches are found then the input will permute the rows of the elements so that the
elements match in the row dimension. There are five options available for row matching.
\itemize{
  \item \code{"Yes"} Perform an exact name match between the row names of input elements.
  Any row names that are not matched in the other outputs are permissible, however that
  row is then treated as missing values. The resulting row will either be \code{NA} if
  \code{remove.missing} is set to \code{FALSE} or zero if \code{remove.missing} is set
  to \code{TRUE}.
  \item \code{"Yes - hide unmatched"} Performs an exact name match between
  input elements in the same manner as \code{"Yes"} option. However, unmatched row names
  will cause the entire row to be removed before calculation.
  \item \code{"Fuzzy"} Same behaviour as \code{"Yes"} except the matching uses fuzzy name
  matching. First an exact name match is performed, any remaining unmatched elements are attempted to
  be matched using near matches using the Levenshtein distance. The algorithm will
  match elements that have a one-to-one matching with a Levenshtein distance of
  at most 1 unit, ignoring case. Following this, some common variants of questionnaire
  reponses are attempted to be matched. E.g. \code{"None of these"} could be matched
  with \code{"none"}. This occurs for variants of \code{"Other"}, \code{"All of these"}
  and variants of \code{"Don't know"}. If further unmatched elements exist, punctuation
   and white space are removed and matches attempted. If any unmatched still exist, then
  they are appended a value of zero before calculation in the same manner as
  \item \code{"Fuzzy - hide unmatched"} Similar to \code{"Fuzzy"} except any unmatched row
  names cause the entire row to be removed from the calculation in a similar way to
  \code{"Yes - hide unmatched"}.
  \item \code{"No"} No matching is to occur with the row names. In this case, all
  input elements need to have the same number of rows.
  }}

\item{match.columns}{Performs matching on the column names of the inputs. The behaviour
and argument options are the same as \code{match.rows} except the algorithm performs
them on the column names.}

\item{subset}{Logical vector of units to use in the calculation. Only applied to variables and
not to \code{Q Table}s that contain statistics since the original variable data is unavailable.}

\item{weights}{Numeric vector of weights to use in the calculation. Only applies to variables
and not to \code{Q Table}s that contain statistics since the original variable data is unavailable.}

\item{warn}{Logical element to control whether warnings are shown when non-obvious
operations are performed (e.g., removing rows, removing missing values when they are present).
Possible warnings presented include \itemize{
  \item Whether missing values were identified and removed if \code{remove.missing}
    is set to \code{TRUE}
  \item Whether different statistics are being summed in the case of \code{Q Table}.
  \item Whether unmatched rows or columns have been removed from the calculation if the user
  has specified for unmatched elements to be hidden.
  \item Whether any inputs have been reshaped.
}}
}
\value{
The \code{Average} function returns the arithmetic mean of all the elements provided in the input,
  possibly after the elements have had entries removed, filtered out or weighted using the provided
  options.

The \code{AverageColumns} function returns the summation of all the elements in each column
  index provided in the input, possibly after the elements have been pre-processed similar
  to \code{Sum}.

The \code{AverageRows} function returns the arithmetric mean of all the elements in each row
  index provided in the input, possibly after the elements have been pre-processed similar
  to \code{Average}.
}
\description{
\code{Average} is a generalization of the arithmetic \code{\link{mean}} function
 but supporting additional pre-processing and matching of data before calculation
 by utilizing the \code{\link{Sum}} function to compute the numerator.

In a similar way, \code{AverageRows} is a generalization of \code{\link{rowMeans}} but
 not supporting row or column matching for multiple inputs that is supported in \code{Average}.
}
\details{
For \code{Average}, if a single input element is provided, then the element is added in the same
  way as \code{\link{mean}}, i.e. all elements added together to give a single scalar value.
  If multiple input elements are provided, then element-wise addition is performed in a similar way
  to the + function in \code{\link{Arithmetic}}. In the case of multiple inputs, the dimensions need to match before elementwise
  addition can occur. i.e. if the first element is a 3 x 2 matrix, then the second element needs to be
  a matrix of the same dimension. Partial dimension matching is also supported, so if an n x p matrix is
  used as the first input, then the second input could be an n x 1 column vector that is reshaped to an
  n x p matrix before calculation.

If a single input is provided to \code{AverageRows} and \code{AverageColumns}, it is
 permissible to be a \code{numeric} vector, \code{data.frame}, \code{Q Table}, \code{matrix} or
 other possible structure that has well defined rows or columns. An array is only
 permissible if it has 2 dimensions. Higher order arrays are only allowed in the form of
 a \code{Q Table}. Multiple inputs are allowed but only if each input is a single \code{numeric}
 vector with the same number of rows (a vector with n elements is interpreted as a matrix with
 n rows and 1 column) or the input elements can be reduced to that situation. For example,
 an n x p \code{matrix} or \code{data.frame} can be converted to p separate vectors with n rows.

 For \code{AverageRows} the sum is computed not element-wise but across the whole row dimension
 E.g. a n x p matrix supplied to \code{AverageRows} will produce a vector or column vector of
 of length \code{n}. If names are provided in the row dimension of the input then the output will have the same
 row names.
}
\examples{
# Examples using average
Average(1:6)
mean(1:6)
input.matrix <- matrix(runif(6), nrow = 3, dimnames = list(letters[1:3], c("Q1", "Q2")))
mean(input.matrix)
Average(input.matrix)
Average(1:6, 1:6)
((1:6) + (1:6))/2
x <- 1:6
y <- sample(1:6)
y
Average(x, y)
(x + y)/2
is.na(y) <- 3
is.na(x) <- 3:4
Average(x, y)
x <- matrix(1:12, nrow = 4, ncol = 3, dimnames = list(letters[1:4], LETTERS[1:3]))
y <- matrix(1:20, nrow = 5, ncol = 4, dimnames = list(letters[1:5], LETTERS[1:4]))
Average(x, y, remove.rows = "e", remove.columns = "D")
x <- matrix(1:12, nrow = 4, ncol = 3, dimnames = list(letters[1:4], letters[1:3]))
y <- matrix(1:20, nrow = 5, ncol = 4, dimnames = list(LETTERS[1:5], LETTERS[1:4]))
Average(x, y, match.rows = "Yes", match.columns = "Yes")
Average(x, y, match.rows = "Fuzzy", match.columns = "Fuzzy")
# Examples using SumColumns
input.matrix <- matrix(1:8, nrow = 4)
AverageColumns(input.matrix) #= c(10, 26)
named.matrix <- input.matrix
dimnames(named.matrix) <- list(LETTERS[1:4], letters[1:2])
AverageColumns(named.matrix)
AverageColumns(named.matrix, remove.rows = c("A", "C"))
AverageColumns(named.matrix, subset = c(TRUE, FALSE, TRUE, FALSE))
AverageColumns(named.matrix, remove.rows = c("B", "D"))
# Each element is summed individually
# The order of input determines the order of output.
w <- c(a = 1, b = 2, c = 3, d = 4)
x <- c(a = 1, b = 2)
y <- c(b = 3, c = 10)
z <- c(c = -1, d = 3)
AverageColumns(w, x, y, z)
AverageColumns(z, y, x, w)
AverageColumns(sample(w), sample(x), sample(y), sample(z))
# Examples using AverageRows
input.matrix <- matrix(runif(6), nrow = 3, dimnames = list(letters[1:3], c("Q1", "Q2")))
AverageRows(input.matrix)
input.matrix.with.total <- cbind(input.matrix, "Total" = rowSums(input.matrix))
AverageRows(input.matrix.with.total) # The total column is removed by default
colnames(input.matrix.with.total) <- c("Q1", "Q2", "tot")
# This will include the total in the calculation since the non-standard Total label is used.
AverageRows(input.matrix.with.total)
AverageRows(input.matrix.with.total, remove.columns = "tot")
v3 <- matrix(runif(3), nrow = 3, dimnames = list(letters[1:3], "Q3"))
AverageRows(input.matrix, v3)
input.df <- data.frame(V1 = runif(3), V2 = runif(3))
AverageRows(input.matrix, input.df)
}
