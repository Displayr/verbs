% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/count-operators.R
\name{Count}
\alias{Count}
\alias{AnyOf}
\alias{NoneOf}
\alias{CountEachRow}
\alias{CountEachColumn}
\alias{AnyOfEachRow}
\alias{AnyOfEachColumn}
\alias{NoneOfEachRow}
\alias{NoneOfEachColumn}
\title{Checking occurrences or counts of elements in inputs}
\usage{
Count(
  ...,
  remove.rows = NULL,
  remove.columns = NULL,
  match.elements = "Yes",
  elements.to.count = list(categorical = NA_character_, numeric = NA_real_),
  ignore.missing = TRUE,
  subset = NULL,
  warn = TRUE
)

AnyOf(
  ...,
  remove.rows = NULL,
  remove.columns = NULL,
  match.elements = "Yes",
  elements.to.count = list(categorical = NA_character_, numeric = NA_real_),
  ignore.missing = TRUE,
  subset = NULL,
  warn = TRUE
)

NoneOf(
  ...,
  remove.rows = NULL,
  remove.columns = NULL,
  match.elements = "Yes",
  elements.to.count = list(categorical = NA_character_, numeric = NA_real_),
  ignore.missing = TRUE,
  subset = NULL,
  warn = TRUE
)

CountEachRow(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA_integer_, numeric = NA_integer_),
  ignore.missing = TRUE,
  warn = TRUE
)

CountEachColumn(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA_integer_, numeric = NA_integer_),
  ignore.missing = TRUE,
  warn = TRUE
)

AnyOfEachRow(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA, numeric = NA),
  ignore.missing = TRUE,
  warn = TRUE
)

AnyOfEachColumn(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA, numeric = NA),
  ignore.missing = TRUE,
  warn = TRUE
)

NoneOfEachRow(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA, numeric = NA),
  ignore.missing = TRUE,
  warn = TRUE
)

NoneOfEachColumn(
  x,
  remove.rows = NULL,
  remove.columns = c("NET", "SUM", "Total"),
  elements.to.count = list(categorical = NA, numeric = NA),
  ignore.missing = TRUE,
  warn = TRUE
)
}
\arguments{
\item{...}{Objects to be summed; e.g. vectors, matrices, Variables, Variable Sets or Q Tables}

\item{remove.rows}{The labels of named vectors, or, rows of tables and similar
structures to be removed from the row dimension of the input. Any row elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{remove.columns}{The labels of columns of tables and similar
structures to be removed from the column dimension of the input. Any column elements
with the labels specified here will not be included in the resulting \code{Sum}
calculation.}

\item{match.elements}{Either a single string with three possible options or named character vector with two elements. The possible single character options are: \itemize{
\item "No": Ignores names and requires either inputs which the same dimensions
      or partially agreeing where recycling can be performed. See details for more information.
\item "Yes - hide unmatched" or "Yes": Performs a matching algorithm that checks row names and column names
      of all elements and attempts to match the appropriate elements. The matching
      will check both exact matches or fuzzy matches and permutes the order of the elements
      so that the names match. It also may transpose an input if,
      for example, the column names of one input match the row names of another input.
      Any unmatched elements are removed from the input before calculation.
\item "Yes - show unmatched": Performs the same matching algorithm above but any
      unmatched elements are kept in the input. The other input without the element has
      missing values spliced in.
      }
 A named character vector is possible but it must have two elements named \code{rows}
 or \code{columns} (partial matching names permissible) that specify the matching behavior
 for rows and columns.
 E.g. \code{match.elements = c(rows = "Yes - hide unmatched", columns = "No")} to specify
 that rows are to be matched but unmatched rows are to be removed from the calculation.
 The columns are not to be matched. The full set of alternatives for either \code{match.rows}
 or \code{match.columns} are given below but are described only for the row scenario.
\itemize{
  \item \code{"Yes"} or \code{"Yes - hide unmatched"}: Perform an exact name match between
  the row names of input elements. Any unmatched row names will cause the entire row to be
  removed before calculation.
  \item \code{"Yes - show unmatched"} Performs an exact name match between
  input elements in the same manner as \code{"Yes"} option. However, any row names that are
  not matched in the other outputs are permissible. The input that doesn't have that row
  will have a row of missing values spliced in. The resulting row will either be \code{NA} if
  \code{remove.missing} is set to \code{FALSE} or zero if \code{remove.missing} is set
  to \code{TRUE}.
  \item \code{"Fuzzy"} Same behaviour as \code{"Yes"} except the matching uses fuzzy name
  matching. First an exact name match is performed, any remaining unmatched elements are attempted to
  be matched using near matches using the Levenshtein distance. The algorithm will
  match elements that have a one-to-one matching with a Levenshtein distance of
  at most 1 unit, ignoring case. Following this, some common variants of questionnaire
  reponses are attempted to be matched. E.g. \code{"None of these"} could be matched
  with \code{"none"}. This occurs for variants of \code{"Other"}, \code{"All of these"}
  and variants of \code{"Don't know"}. If further unmatched elements exist, punctuation
   and white space are removed and matches attempted.
  \item \code{"Fuzzy - show unmatched"} Similar to \code{"Fuzzy"} except any unmatched row
  names will have a row of missing values spliced in similar to \code{"Yes - show unmatched"}.
  \item \code{"No"} No matching is to occur with the row names. In this case, all
  input elements need to have the same number of rows.
  }}

\item{elements.to.count}{Specifies the conditions to identify which elements are used in \code{Count},
\code{AnyOf} or \code{NoneOf}. The format should either be a list, a character vector or a numeric vector.
If a \itemize{
\item numeric vector is provided: it is assumed to contain the individual values to be checked in
the input for \code{AnyOf}, \code{Count} or \code{NoneOf} calculations.
\item character vector is provided: it is assumed to contain the level labels to be checked in factor
inputs provided.
\item a list is provided: It is assumed to contain at least one named element. The two possible names
are \code{'categorical'} and \code{'numeric'}. The \code{'categorical'} element should contain a
character vector of levels as described above for any factor variables. The \code{'numeric'} element can
either be a numeric vector or it can be a single character element. If the latter is provided,
 it will be parsed into a more general list of numeric conditions. The more general numeric condition
 list has the following possible elements.
    \itemize{
         \item \code{'values'}: A numeric vector of values to check in the input (NA permissible here to check for missing
 values)
         \item \code{'lt'}: A single numeric value to denote a less than condition.
         \item \code{'lte'}: A single numeric value to denote a less than or equal condition.'
         \item \code{'gt'}: A single numeric value to denote a greater than condition.'
         \item \code{'range'}: A list where each elements contains two numeric values
          to denote a closed interval e.g. c(1L, 2L) denotes the range 1 <= x <= 2.
     }
 }}

\item{ignore.missing}{Logical element controlling whether missing values should be
be ignored during calculations? Defaults to \code{TRUE}. If set to \code{FALSE} and if one of
input elements contains missing values, then the resulting computed count will also be
\code{NA}. In the case of \code{\link{AnyOf}} or \code{\link{NoneOf}}, the result will only be \code{NA}
if all other elements in the calculation are \code{FALSE} for their respective calculation.}

\item{subset}{Logical vector of units to use in the calculation. Only applied to variables and
not to Q Tables that contain statistics since the original variable data is unavailable.}

\item{warn}{Logical element to control whether warnings are shown when non-obvious
operations are performed (e.g., removing rows, removing missing values when they are present).
Possible warnings presented include \itemize{
  \item Whether missing values were identified and removed if \code{remove.missing}
    is set to \code{TRUE}
  \item Whether different statistics are being summed in the case of Q Table.
  \item Whether unmatched rows or columns have been removed from the calculation if the user
  has specified for unmatched elements to be hidden.
  \item Whether any inputs have been recycled to higher dimensional forms.
}}

\item{x}{A single input to be used when performing the calculation on each row/column
dimension in \code{AnyOfEachRow}, \code{CountEachRow}, \code{NoneOfEachRow}, \code{AnyOfEachColumn}, \code{CountEachColumn}, \code{NoneOfEachColumn}.}
}
\description{
\code{Count} gives the total count of elements that satisfy some pre-specified conditions
 in the case of a single input and the count produced element wise for multiple inputs.

\code{AnyOf} checks if any of the elements satisfy some pre-specified conditions
 in the case of a single input. In the case of for multiple inputs the check is performed elementwise.

\code{NoneOf} checks if none of the elements satisfy some pre-specified conditions
 in the case of a single input. In the case of for multiple inputs the check is performed elementwise.
 It is the complement of \code{AnyOf}.

 Similar to \code{\link{Sum}}, the inputs can be matched via their row and/or column names
 in the case of multiple inputs with the output element being filtered by row and/or column.
}
\examples{
test.array <- array(1:18, dim = c(3L, 6L))
test.array[7] <- NA
counting.condition <- list(numeric = list(values = c(NA, 1, 2, 3),
                           gt = 17, range = list(c(4, 5), c(10, 15))))
Count(test.array, elements.to.count = counting.condition)
counting.cond.as.str <- "NA,1,2,3,>17,4-5,10-15"
Count(test.array, elements.to.count = list(numeric = counting.cond.as.str))
test.factor <- factor(sample(c("Apples", "Oranges", "Grapes", NA), size = 100, replace = TRUE))
Count(test.factor, elements.to.count = c("Oranges", "Grapes", NA))
}
